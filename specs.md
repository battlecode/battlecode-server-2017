Battlecode 2013 Gameplay Specs
==============================

Plot
--------

After being foiled yet another year by the power of fun gamers, the evil Professor Mordemort was captured and placed in the most secured cell in the Galactic Hold.
Now, it is one year after those terrible events, and peace reigns supreme in the galaxy, new and faster methods of reaching far off planets being provided by 
Vanqeri Technologies, and the Interuniverse Defense League is stronger than ever. However, there are rumors of an unknown force that is attacking planets on the
outer rim of the galaxy, an enemy that is rumored to be using ancient technology and trench warfare to gain the upper-hand. The IDL is calling on Coders throughout
the galaxy to help combat this unknown enemy before the devastation they are causing reaches the more populated worlds. 


Objective
----------------

The objective this year is simple. Violently eliminate the opponent's HQ through a constant barrage of soldiers.

There are many encampments across the map that may aid in this endeavor, allowing you to fortify positions and take map control.

Should you need them, you may also research a number of upgrades that provide you with a large tactical advantage on the battlefield.

Good luck!


Changes from 2012
------------------

There are a number of large changes from previous Battlecode years, so even if you're a veteran you may want to read this section. In approximate order of how huge a change it is:

- Robots no longer face a direction. There is no turning, and no concept of forwards and backwards. Instead, robots can just move to any adjacent square.
- There are no longer voids on the map. Every square on the map is traversable, and there is no longer any distinction between ground and air units.
- Both teams start off knowing exactly what the map looks like. They know where all the map edges are and know where the enemy spawns. 
- There are no movement or attack delays(though some actions do still incur a cool-down). Soldiers move and attack once every turn.
- Units always have shared vision and can sense anything within the vision radius of any allied unit.
- Flux has been renamed to power; now it is globally shared among all of a team's units, so flux transfer has been removed.
- Broadcasting has been completely altered. Both teams now write to a global array of integers. Broadcasting no longer relies on robots being within a broadcast radius.

NOTE: Numbers in the doc are provided for readability and are actually governed by game constants that may change. Check the API for full details.


Robot Overview
-----------------

Robots are the central part of the Battlecode world. There are two types of basic units, specified by the `RobotType` enum.

### HQ
Each team starts the game off with one HQ. The game is over when one of the team's HQ is destroyed. The HQ can either spawn SOLDIERs or research TECH upgrades. The game ends when one team loses their HQ.  If the game reaches the round limit, HQs will also begin taking end-of-round damage to break ties.

### SOLDIER
SOLDIERs form the core of your army. Use them to fight your way to victory. They auto-attack all units around them and can also capture encampments to give their army a strategic bonus.


Encampments
------------

In addition to the two basic units, there are special units called ENCAMPMENTS that can be created on top of unoccupied encampment squares.

If a soldier is located on an encampment square, it has the option to capture the square (after `GameConstants.CAPTURE_DELAY`) and turn it into one of the following encampments:

1. **MEDBAY**: Adjacent allied units are healed for `MEDBAY.attackPower` health per turn

2. **SHIELDS**: The shield encampment automatically provides a bonus of `SHIELDS.attackPower` shields to a given unit. This shield absorbs damage from artillery fire only. Shields decay at a constant rate of `GameConstants.SHIELD_DECAY_RATE`.

3. **ARTILLERY**: The artillery encampment allows a unit to attack a position on a map, causing `ARTILLERY.attackPower` damage to the attacked square, and `ARTILLERY.attackPower/2` splash damage to the adjacent squares. The splash damage can damage friendly units, so watch where you fire.

4. **GENERATOR**: Generators provide you with `GameConstants.GENERATOR_RESOURCE_PRODUCTION` extra power per turn.

5. **SUPPLIER**: Each supplier decreases your spawn delay.

The other team may retake an encampment square if the existing encampment on it is destroyed.


Robot Resources
------------------

There are three basic type of unit resources, POWER and ENERGON, and SHIELDS.

### Energon
Energon is health. When a robot's energon hits zero, it is immediately removed from the game. Energon can only be regained by healing at a MEDBAY.

### Power

Power is shared globally across the team and is generated by the HQ at 40 power per round (`GameConstants.HQ_RESOURCE_PRODUCTION`).  4 Additional power can be generated by GENERATOR encampments (`GENERATOR_RESOURCE_PRODUCTION`).

Units require a fixed amount of power at the beginning of its turn to perform action. If enough power is not available, then the unit will still execute, but will lose energon instead.

At the end of a robot's turn, if the bot did not use its full bytecode allocation, a fraction of the energy is refunded based on bytecodes used. An unlimited amount of energy can be stockpiled.

### Shields

Shields are generated from the SHIELD encampment and provide protection only from artillery fire damage. Shields decay at a constant rate of `GameConstants.SHIELD_DECAY_RATE` per turn.


Upgrades
--------

Upgrades are research-able from your HQ. The following upgrades are available:

1. **Pickaxe**: In addition to mining the square underneath a SOLDIER, the 4 orthogonally adjacent squares are also mined.
2. **Diffusion**: Robots can defuse not only adjacent tiles, but any mines in its personal sight radius.
3. **Vision**: Increases the sight radius on all robots and the base from 10 to 32 radius squared
4. **Fusion**: The team's decay rate is adjusted from `RESOURCE_DECAY_RATE` to `RESOURCE_DECAY_RATE_FUSION`.
5. **Nuke**: The enemy team's HQ immediately suicides.

An upgrade must be fully researched before its abilities kick in. An HQ can put one point into an upgrade per turn (unless it recently spawned, see below), and the upgrade is considered completed when `numRounds` of points have been put into it.


Victory Conditions
------------------

A team wins by destroying the enemy's HQ, or by researching the nuke upgrade. We expect most games to end by HQ destruction. The nuke upgrade is intended to be used in extreme stalemate situations. After 2000 rounds (`GameConstants.ROUND_LIMIT`), the HQ starts taking damage. If both teams lose their HQs from end of round damage on the same turn, then the following tiebreakers are applied in order to determine the winner:

- Most encampments
- Most soldiers
- Most mines
- Most energy stockpiled
- Lowest team ID


Robot Actions
--------------

Robots are equipped with a variety of high tech equipments and can perform the following actions during their turn.

### Sensors

All robots are equipped with sensors.

- The position of visible enemy robots are shared between all units.
- The position of known enemy mine locations are shared between all units. Mines are detectable only if an allied unit has previously stepped on it.
- The location of the enemy HQ is automatically known at game start.

### Messaging

There is an "open radio" message board which works as follows: each unit can broadcast or read from a message board on a frequency (between 0 to `MAX_RADIO_CHANNEL` inclusive).  This message board is globally accessible by any robot and is used for communicating whatever the AIs wish to communicate.  Outside of this message board, there is no other way to share arbitrary information (sensor vision information however is still automatically shared).

### Movement

Robots may move up to one round per turn, provided they are not performing any other action (mining, defusing, capturing). Movement is specified by the `rc.move(direction)` command and happens at the end of the robot's turn`

### Spawning

The HQ may spawn one unit per 10 (`GameConstants.HQ_SPAWN_DELAY`) rounds. The spawn rate is reduced for active SUPPLIERS according to the formula a=`GameConstants.HQ_SPAWN_DELAY`*`GameConstants.HQ_SPAWN_DELAY_CONSTANT`/(`GameConstants.HQ_SPAWN_DELAY_CONSTANT`+b), where a is the number of turns it takes to spawn one unit, and b is the number of suppliers you have.  Units that are spawned are immediately placed on the field and may perform actions like any other robot. The HQ cannot do other actions such as research while it is in spawning cooldown.

### Suicide

Calling suicide() immediately kills the calling robot and removes it from the game.

### Team Memory

Each team can save a small amount of information for the next game using the function `setTeamMemory()`. This information may be retrieved using `getTeamMemory()`. If there was no previous game in the match, or no information was saved, the memory will be filled with zeros..

### Control Bits, Indicator Strings, and Breakpoints

There are several ways that the user can interact with robots. First, any robot can use `setIndicatorString(int,String)` to set a string that is visible to the user when mousing over the robot. Second, the user can manually set a long for each robot, which the robot can query using `getControlBits()`. Finally, a robot can call `breakpoint()`, which flags the game engine to pause computation at the end of the round. These methods are for debug purposes only. During tournaments and scrimmages, the user will not be able to interact with the robots. For more information on these debugging interfaces, check out Debugging below.

### Ending turn

Only `yield()` and `suicide()` end the turn of a robot. Otherwise a turn ends naturally when the bytecode limit is hit. Other actions may be performed as many times as attack/movement/broadcast timeouts allow.


Maps
-----

Battlecode maps consist of a grid of squares, each with a pair of integer coordinates. Locations on the map are represented as instances of `MapLocation` objects. 

### Layout

Map coordinates are represented similarly to the pixels on a computer screen: x-coordinates increase moving to the right (East), and y-coordinates increase moving down (South).  The top left corner of the map is guaranteed this year to be coordinate (0,0)

### Map Files

Maps are specified by XML files, and can be found in the maps folder of the release archive. The schema for the files should be fairly intuitive, so if you'd like to add your own maps you can use the provided maps as a basis.

### Map Constraints

- Maps are completely traversable symmetric terrain either by reflection or rotation.
- The size of the map is guaranteed between `MAP_MIN_WIDTH` to `MAP_MAX_WIDTH` dimensions.
- The map can have neutral mines except for the 4 orthogonally adjacent squares to your HQ.
- The map will have neutral encampments scattered across the map. There will be a minimum of `5` (`GameConstants.MAP_MINIMUM_ENCAMPMENTS`) encampments. There will be no encampments orthogonally adjacent to your base


Writing a Player
------------------------

### Introduction

Your player program must reside in a Java package named `teamXXX`, where `XXX` is your three-digit team number, with leading zeros included. You may have whatever subpackages you like. You must define `teamXXX.RobotPlayer`, which must have a public static `run` method that takes one argument of type `battlecode.common.RobotController`. Whenever a new robot is created, the game calls the run method with the robots RobotController as its argument. If this method ever finishes, either because it returned or because of an uncaught exception, the robot dies and is removed from the game. You are encouraged to wrap your code in loops and exception handlers so that this does not happen.

###. RobotController

The RobotController argument to the RobotPlayer constructor is very important -- this is how you will control your robot. RobotController has methods for sensing (e.g. `senseRobotInfo(Robot)`) and performing actions (e.g., `move()`). If you're not sure how to get your robot to do something, the Javadocs for RobotController are a good place to start.

### Example: examplefuncsplayer


```java
import battlecode.common.Direction;
import battlecode.common.GameConstants;
import battlecode.common.RobotController;
import battlecode.common.RobotType;

/** The example funcs player is a player meant to demonstrate basic usage of the most common commands.
 * Robots will move around randomly, occasionally mining and writing useless messages.
 * The HQ will spawn soldiers continuously. 
 */
public class RobotPlayer {
    public static void run(RobotController rc) {
    while (true) {
      try {
        if (rc.getType() == RobotType.HQ) {
          if (rc.isActive()) {
            // Spawn a soldier
            Direction dir = rc.getLocation().directionTo(rc.senseEnemyHQLocation());
            if (rc.canMove(dir))
              rc.spawn(dir);
          }
        } else if (rc.getType() == RobotType.SOLDIER) {
          if (rc.isActive()) {
            if (Math.random()<0.005) {
              // Lay a mine 
              if(rc.senseMine(rc.getLocation())==null)
                rc.layMine();
            } else { 
              // Choose a random direction, and move that way if possible
              Direction dir = Direction.values()[(int)(Math.random()*8)];
              if(rc.canMove(dir)) {
                rc.move(dir);
                rc.setIndicatorString(0, "Last direction moved: "+dir.toString());
              }
            }
          }
          
          if (Math.random()<0.01 && rc.getTeamPower()>5) {
            // Write the number 5 to a position on the message board corresponding to the robot's ID
            rc.broadcast(rc.getRobot().getID()%GameConstants.BROADCAST_MAX_CHANNELS, 5);
          }
        }

        // End turn
        rc.yield();
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
  }
}

```


Notice the while(true) loop, which prevents the run method from returning. While the robot is alive, it will be continually cycling through this loop. The try/catch block inside the loop prevents the robot from throwing an uncaught exception and dying. 




Execution Order
------------------

The following is a detailed map of a robot's execution order to remove ambiguities:

1. Robot's upkeep cost, `GameConstants.UNIT_UPKEEP` is subtracted from the power pool, or if there is insufficient power in the pool, 'GameConstants.UNIT_ENERGON_UPKEEP' is paid in energon (if robot dies, it does not get a turn, and no power is refunded).
2. Robot executes up to `GameConstants.BYTECODE_LIMIT` of code.
3. Power is refunded based on remaining bytecodes by a factor of `GameConstants.ENERGY_COST_PER_BYTECODE`, even if it paid its upkeep with energon.
4. Robots perform actions.

    a. If the robot is on the last turn of mining, the mines are placed on the map (SOLIDER Only)

    b. If the robot is on the last turn of defusing, the mines are removed from the map (SOLIDER Only)

    c. If the robot is on the last turn of capturing, then the encampment is created, and the robot is destroyed (SOLIDER Only)

    d. The robot moves (SOLIDER Only)

    e. Targeted attacks happen (ARTILLERY Only)

    f. Research is updated OR a unit is spawned (HQ Only)

5. Mine damage is applied (SOLIDER Only)
6. Attacks are performed

    a. Robot auto-attacks adjacent enemies (SOLIDER Only)
    
    b. Adjacent units are healed (MEDBAY Only).
    
    c. Adjacent units are shielded (SHIELDS Only).

7. Channels are updated with new broadcasts
8. Shield decay is applied `GameConstants.SHIELD_DECAY_RATE`



Timing
------------------------

Each robot is allowed a certain amount of computation each round. Computation is measured in terms of Java bytecodes, the atomic instructions of compiled Java code. Individual bytecodes are simple instructions such as "subtract" or "get field", and a single line of code generally contains several bytecodes. (For details see http://en.wikipedia.org/wiki/Java_bytecode.) Each round, every player runs a number of bytecodes determined by `GameConstants.BYTECODE_LIMIT`. When a robot hits the bytecode limit, its computation is paused while other robots get to do their computation for the same round or the next round. On the next round, the robot's computation is resumed exactly where it left off. Thus, to the robot's code, the round change is invisible. Nothing will jump out and shout at you when a round ends.

Because the round can change at the end of any bytecode, unexpected things can happen. For instance, consider the following example:

```java
Robot[] nearbyRobots = myRC.senseNearbyGameObjects(Robot.class);
MapLocation loc = myRC.senseRobotInfo(nearbyRobots[0]);
```

In the first line, the robot gets a list of all other robots in its sensor range. In the second line, the robot senses the RobotInfo of the first robot in the list. However, what happens if the round changes between the first and second line? A robot that was in sensor range when line 1 was executed might be out of sensor range when line 2 is executed, resulting in an exception. Because of this, your code should be written defensively. Think of this as a "real-world" robot, where things can fail at any time, and you have to be prepared to handle it.

However, there are ways of dealing with this, as we'll see in the next section.

### Yielding

One way to deal with timing complexities is to use `yield()` judiciously. Calling `RobotController.yield()` ends the robot's computation for the current round. This has two advantages.

First, robots receive a significant flux bonus for yielding computation. The bonus is given by `GameConstants.YIELD_BONUS` * `GameConstants.UNIT_UPKEEP` * (fraction of unused bytecodes in the round).

Second, after a call to `RobotController.yield()`, subsequent code is executed at the beginning of a new round. Then, you have the full amount of bytecodes for your robot to do computations before the round changes. For instance, let's modify the example above to be:

```java
myRC.yield();
Robot[] nearbyRobots = myRC.senseNearbyGameObjects(Robot.class);
MapLocation loc = myRC.senseRobotInfo(nearbyRobots[0]);
```

Since yield is called in line 1, line 2 will be executed at the beginning of a new round. Since `senseNearbyGameObjects()` does not take very many bytecodes, it is pretty much guaranteed that there won't be a round change between lines 2 and 3.

A common paradigm is to have a main loop, with a `yield()` at the bottom of the loop. Thus, the top of the loop is always executed at the beginning of the round. If all the robot's computation for one iteration of the loop can fit in one round, then there should be minimal problems with unexpected round changes. Note that team000 above does this.

### Monitoring

The Clock class provides a way to identify the current round ( `Clock.getRoundNum()` ), and how many bytecodes have been executed during the current round ( `Clock.getBytecodeNum()` ).

### GameActionExceptions

GameActionExceptions are thrown when an ability cannot be performed. It is often the result of uncertainty about the gameworld, or an unexpected round change in your code. Thus, you must write your player defensively and handle GameActionExceptions judiciously. Each GameActionException has a GameActionExceptionType, which tells roughly what went wrong. You should also be prepared for any ability to fail and make sure that this has as little effect as possible on the control flow of your program.

Exceptions cause a bytecode penalty of `GameConstants.EXCEPTION_BYTECODE_PENALTY`.


Mechanics
--------------------

This section deals with some of the mechanics of how your players are run in the game engine, including bytecode-counting, library restrictions, etc.

### Java Language Usage

Players may use classes from any of the packages listed in AllowedPackages.txt, except for classes listed in DisallowedPackages.txt.

Furthermore, the following restrictions apply:

`Object.wait`, `Object.notify`, `Object.notifyAll`, `Class.forName`, and `String.intern` are not allowed.
`java.lang.System` only supports `out`, `arraycopy`, and `getProperty`. Furthermore, `getProperty` can only be used to get properties with names beginning with "bc.testing."
`java.io.PrintStream` may not be used to open files.
Scala functions such as `scala.Console.readByte()` that attempt to read from standard input will always throw an `EOFException`.

Note that violating any of the above restrictions will cause the robots to self-destruct when run, even if the source files compile without problems.

### Bytecode costs

Classes in `java.util`, `java.math`, and scala and their subpackages are bytecode counted as if they were your own code. The following functions in `java.lang` are also bytecode counted as if they were your own code.

```
Math.random
StrictMath.random
String.matches
String.replaceAll
String.replaceFirst
String.split
```

The function `System.arraycopy` costs one bytecode for each element copied. All other functions have a fixed bytecode cost. These costs are listed in the `MethodCosts.txt` file. Functions not listed in `MethodCosts.txt` are free. The bytecode costs of battlecode.common functions are also listed in the javadoc.

### Memory Usage

Robots must keep their memory usage reasonable. If a robot uses more than 8 Mb of heap space during a tournament or scrimmage match, the robot may be killed.

### Exceptions

Throwing exceptions of any kind incurs a bytecode penalty given by `GameConstants.EXCEPTION_BYTECODE_PENALTY`, so unnecessary throwing of exceptions should be avoided.

### Virtual Machine Errors

Your player cannot catch virtual machine errors such as `StackOverflowError` and `OutOfMemoryError`. If your robot throws one of these exceptions, it will die.

### Java version

Our scrimmage and tournament servers will be running Java 6 and Scala 2.9. The Battlecode software should run on Java 7, but please be aware that our compile server will not recognize Java 7 specific language features.





Debugging
-------------------

This section describes some of the features of the game engine intended to make debugging somewhat less painful. Debug mode reveals valuable information about robots at development time but will be turned off for scrimmages and real tournaments.

### System.out

Any output that your robots print to System.out is directed to the output stream of the Battlecode engine, prefixed with information about the robot.

### Debug Methods

The game engine has a feature that allows you to separate out debugging code that is unimportant to your player's performance in the tournament. Methods that have names beginning with debug_ and that have a void return type are given special status. By default, these methods are skipped during execution of the player. When the System property debugMethodsEnabled is set to true, however, the methods are executed normally except that they do not count against your robot's bytecode limit. Code that prepares the arguments to such a method may consume bytecodes, but the body of the method and any methods that it invokes are not counted.

### System Properties

Your robot can read system properties whose names begin with "bc.testing.". You can set a property by adding a line to bc.conf like this:

```
bc.testing.team-a-strategy=experimental
```

You can check the value of the property like this:

```
String strategy = System.getProperty("bc.testing.team-a-strategy");
```

### Breakpoints

Breakpoints allow you to pause the game engine's calculations. If breakpoints are enabled (see the software page), and a robot calls RobotController.breakpoint(), the game engine will stop computing at the end of the round. This gives you a chance to see exactly what's going on in the game when your robot hits a certain point in its code. You can resume the game engine's computation in the client, by hitting the "resume" button. If the match is being dumped straight to a file (i.e., there is no client to resume the game), breakpoints are ignored.

Note that when a robot calls breakpoint(), computation will be stopped at the end of the round, not immediately when breakpoint() is called. Depending on the circumstances, you might want to use breakpoint(); yield(); instead.



Tournaments & Course Credit
---------------------------

There are five tournaments: the Sprint, Seeding, Qualifying, Final, and Newbie tournaments. Check the Calendar page for dates and locations. Here, we'll explain the mechanics of how the tournaments are run.

The Sprint Tournament is a single elimination tournament. Contestants are seeded based on scrimmage ranking, and play continues until there is only one undefeated team.

The Seeding Tournament is a single elimination tournament. Contestants are seeded based on scrimmage ranking, and play continues until there is only one undefeated team. The results of this tournament are used to determine seeds for the Qualifying and Newbie tournaments. Teams are ranked by the following criteria, in order:

- Furthest round achieved
- Bayesian Elo rating for the tournament (computed on a per-game basis, not a per-match basis)

The Qualifying Tournament is a double elimination tournament (see e.g. http://en.wikipedia.org/wiki/Image:NSB-doubleelim-draw-2004.png). Play continues until there are 8 teams remaining. These teams move on to the Final Tournament. Teams are seeded for the final tournament as follows:

- The four teams that did not lose a match receive the top four seeds.
- Teams that did not lose a single game are ranked by their qualifying seeds.
- The remaining teams are ranked by Bayesian Elo rating for the tournament (computed on a per-game basis).
- The Final Tournament is another double elimination tournament. The Final Tournament starts with a blank state, i.e., any losses in the Qualifying Tournament are erased.

The Newbie Tournament will run concurrently with the Qualifying Tournament. All teams consisting entirely of MIT students who have not participated in Battlecode before will automatically be entered into the Newbie tournament in addition to the other tournaments. We will announce the format of the Newbie tournament soon.

In order to receive credit for the course, or to be eligible for the newbie tournament, you must register with an mit.edu e-mail address. If you already registered with a different e-mail address, please let us know.

You can receive credit for the course by defeating the reference player. You must defeat Teh Devs in an unranked scrimmage on a certain set of maps. These maps will be announced approximately two weeks into the course. If your player beats the reference player, everyone on your team receives 6 credits.

If your submission does not beat the reference player, then you can get credit an alternate way, by sending us a 2-page report on your player: its code design, how it works, an explanation of any AI paradigms you used, etc. We will look over your source code and your report, and if both show a significant amount of effort, thought, and good design techniques, we will give you 6 credits.

We give prizes for the best strategy reports, so we encourage you to submit a report even if you defeat the reference player.

Also, note that you are allowed to drop 6.370 without penalty very **late** into IAP.



Getting Help
-------------

We have both a forum and an IRC Channel (#battlecode on irc.freenode.net).



Disclaimers
-------------

We have done our best to test and balance the properties of the Battlecode world. Inevitably, however, we will need to make adjustments in the interest of having a fair competition that allows a variety of creative strategies. We will endeavor to keep these changes to a minimum, and release them as early as possible. All changes will be carefully documented in the ChangeLog.

Despite our best efforts, there may be bugs or exploits that allow players to operate outside the spirit of the competition. Using such exploits for the tournament or scrimmage will result in immediate disqualification, at the discretion of the directors. Such exploits might include, but are not limited to, robot communication without messages, bypassing the bytecode limit, or terminating the game engine. If you are not sure what qualifies as "in the spirit of the competition", ask the devs before submitting your code.


Appendices
------------

### Appendix A: Javadocs and Game Constants

Javadocs can be found here, and they are also included in the software distribution.

The javadocs include the values of the game constants and robot attributes.

We also have a handy unit reference chart.

### Appendix B: Energon Health Warning

Energon intake is not for everyone. Please consult a physician before use. 6.370 Battlecode Corporation is not responsible in the event of injury due to energon use. Energon's side-effects include loss of limb, death, unbearable pain, tendencies to procrastinate and an unnatural senseless rage. Handle with care. Energon consumption has not been approved by any health agency and you USE IT AT YOUR OWN RISK. For this reason, please be careful when scrimmaging.

